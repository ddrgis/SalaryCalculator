# Salary Calculator
Тестовое задание для одной из компаний

## Текст задания
Написать программу для расчета зарплат в компании.
В задании указаны типы сотрудников и их жестко заданные алгоримы зачисления зарплат.
Написать нужно на C# + SQLite. При решении нужно акцентироваться на архитектуре, не на быстродействие.

## Состояние задания
### Сделано:
* Доменная модель
* Каркас архитектуры
* Функционал расчета зарплат (всех сотрудников и по отдельноести)
* Написаны основные тесты для доменной модели
* CRUD операции над сотрудниками (не протестирвано)
* Простроение дерева всех сотрудников или подчиненных (не протестирвано)
### Осталось сделать:
* Возможность просматривать подчиненных (получение подчиненных сделано, осталось добавить форматированный вывод)
* Пользовательский интерфейс
* Систему авторизации, с суперпользователем и разграничением прав
* Задачи из "To do List" влияющие на функционал

## Обзор архитектуры
Архитектурно приложение разбито на несколько слоев, в целом это разбитие можно назвать Onion архитектурой, каждый слой зависит только от нижних слоев.
В самом низу находится доменная модель, выше над ней слой с интерфейсами, которые исплозуют доменную модель и на самом верхнем слое находится слой с остальной 
инфраструктурой: доступ к базе данных, пользовательский интерфейс и реализация сервисов для работы с домменной моделью. 
Плюсы такой архитектуры: DDD разработка, слабая связанность, доменная модель не имеет зависимостей от других слоев, просто изменять реализацию внешних компонентов,
при соблюдении слабой связанности. Вехний слой может иметь зависимость от нижнего, что сокращает количество кода, в сравнении с классической 3 уровневой архитектурой.

Для хранения иерархии наследования в базе был выбран способ TPH, т.к. все типы были реализованы с одинаковыми свойствами.
Для хранения древовидной структуры был выбран самый простой метод Adjacency List. Этот способ подойдет для небольних деревьев. Для подобного приложения, с большими деревьями, он не подойдет.

В текущей реализации, каждый сотрудник может иметь только одного босса. Нельзя поменять бонусы к зарплате при создании работника через EmployeeFactory.
Немного неудачно выбрано имя абстрактного класса Person, его стояло бы назвать Employee, но Employee уже используется наследником (не стал менять т.к. этот тип написан в задании), 
из-за этого названия многих методов могут сбивать с толку.

## To do List
* Сделать todo list из кода (Visual studio task list)
* Дописать недостающие тесты, в особенности для SalaryService
* Логику расчета зарплаты нужно вынести из класса Person в отдельный класс (Single and O/C principles)
* Абстрогироваться от конкретной базы данных и конкретной строки подключения
* Удалить лишнии packages
* Добавить хранение глубины сотрудника в дереве
* Добавить кеширование списка сотрудников
* Добавить возможность расчета суммарной зарплаты для леса из деревьев (когда нет одного общего босса)
* Добавить индексацию БД
* Протестировать репозиторий
* Перезагрузить методы Equals и GetHashCode для Person
* Протестировать EmployeeService
* Округленние зарплат

## Список возможных улучшений
* Для хранения денег лучше использовать decimal или пользовательский тип Money
* Если в программе будет много операций со временем, то для этого лучше использовать сторонную библиотеку вроде NodaTime
* Если будут другие таблицы в БД, то было бы не плохо сделать обобщенний репозиторий и UnitOfWork
* Расчет зарплаты для дат в будущем. Текущая реализация не предусматривает возможность расчета зарплаты на момент в будущем

## Использованные технологии и библиотеки

.NET Framework 4.6, C# 7.0, SQLite, Dapper, NUnit, NSubstitute